#!/usr/bin/env python3
"""
Configuration management for S&D - Search & Destroy
"""
import json
import logging
import os
from pathlib import Path
from typing import Any, Dict

# XDG Base Directory specification paths
XDG_CONFIG_HOME = os.environ.get(
    "XDG_CONFIG_HOME",
    os.path.expanduser("~/.config"))
XDG_DATA_HOME = os.environ.get(
    "XDG_DATA_HOME",
    os.path.expanduser("~/.local/share"))
XDG_CACHE_HOME = os.environ.get(
    "XDG_CACHE_HOME",
    os.path.expanduser("~/.cache"))

APP_NAME = "search-and-destroy"
CONFIG_DIR = Path(XDG_CONFIG_HOME) / APP_NAME
DATA_DIR = Path(XDG_DATA_HOME) / APP_NAME
CACHE_DIR = Path(XDG_CACHE_HOME) / APP_NAME

# Ensure directories exist
CONFIG_DIR.mkdir(parents=True, exist_ok=True)
DATA_DIR.mkdir(parents=True, exist_ok=True)
CACHE_DIR.mkdir(parents=True, exist_ok=True)

CONFIG_FILE = CONFIG_DIR / "config.json"
SCAN_REPORTS_DIR = DATA_DIR / "scan_reports"
QUARANTINE_DIR = DATA_DIR / "quarantine"
LOG_DIR = DATA_DIR / "logs"

# Create subdirectories
SCAN_REPORTS_DIR.mkdir(exist_ok=True)
QUARANTINE_DIR.mkdir(exist_ok=True)
LOG_DIR.mkdir(exist_ok=True)


def setup_logging() -> logging.Logger:
    """Setup application logging with rotation."""
    logger = logging.getLogger(APP_NAME)
    if not logger.handlers:
        # Create formatter
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
        )

        # File handler with rotation
        from logging.handlers import RotatingFileHandler

        log_file = LOG_DIR / "application.log"
        file_handler = RotatingFileHandler(
            log_file, maxBytes=10 * 1024 * 1024, backupCount=5
        )
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.INFO)

        # Console handler for debug
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        console_handler.setLevel(logging.WARNING)

        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        logger.setLevel(logging.INFO)

    return logger


def get_minimal_initial_config() -> Dict[str, Any]:
    """Get minimal initial configuration for first-time setup."""
    return {
        "scan_settings": {
            "max_threads": 4,
            "timeout_seconds": 300,
        },
        "ui_settings": {
            "minimize_to_tray": True,
            "show_notifications": True,
            "activity_log_retention": 100,
        },
        "security_settings": {
            "auto_update_definitions": True,
        },
        "advanced_settings": {
            "scan_archives": True,
            "follow_symlinks": False,
            "scan_depth": 2,
            "file_filter": "all",
            "memory_limit": 1024,
            "exclusion_patterns": "",
        },
        "realtime_protection": {
            "monitor_modifications": True,
            "monitor_new_files": True,
            "scan_modified_files": False,
        },
        "rkhunter_settings": {
            "enabled": False,
            "run_with_full_scan": False,
            "auto_update": True,
            "categories": {
                "applications": False,
                "network": True,
                "rootkits": True,
                "system_commands": True,
                "system_integrity": True,
            },
        },
        "scheduled_settings": {
            "enabled": False,
            "frequency": "daily",
            "time": "02:00",
        },
        "paths": {
            "quarantine_dir": str(QUARANTINE_DIR),
            "scan_reports_dir": str(SCAN_REPORTS_DIR),
            "log_dir": str(LOG_DIR),
            "temp_dir": str(CACHE_DIR / "temp"),
        },
    }


def load_config(file_path: str = None) -> Dict[str, Any]:
    """Load configuration from file. If no config exists, create one with minimal defaults."""
    config_path = Path(file_path) if file_path else CONFIG_FILE
    try:
        with open(config_path, "r", encoding="utf-8") as config_file:
            config = json.load(config_file)
            # Return the config as-is - no merging with defaults
            return config
    except FileNotFoundError:
        # Create minimal initial config if none exists
        initial_config = get_minimal_initial_config()
        save_config(initial_config, str(config_path))
        return initial_config
    except json.JSONDecodeError as e:
        logging.getLogger(APP_NAME).error("Invalid JSON in config file: %s", e)
        # Backup corrupted config and create new one
        import shutil
        shutil.move(str(config_path), str(config_path) + ".corrupted")
        initial_config = get_minimal_initial_config()
        save_config(initial_config, str(config_path))
        return initial_config


def save_config(config_data: Dict[str, Any], file_path: str = None) -> None:
    """Save configuration to file."""
    config_path = Path(file_path) if file_path else CONFIG_FILE
    try:
        with open(config_path, "w", encoding="utf-8") as config_file:
            json.dump(config_data, config_file, indent=4, sort_keys=True)
    except (IOError, OSError) as e:
        logging.getLogger(APP_NAME).error("Failed to save config: %s", e)


def get_default_config() -> Dict[str, Any]:
    """Get default configuration values - ONLY used for 'Default Settings' button."""
    return {
        "scan_settings": {
            "scan_archives": True,
            "scan_email": True,
            "scan_ole2": True,
            "scan_pdf": True,
            "scan_html": True,
            "scan_executable": True,
            "max_filesize": "100M",
            "max_recursion": 16,
            "max_files": 10000,
            "pcre_match_limit": 10000,
            "pcre_recmatch_limit": 5000,
            "max_threads": 4,
            "timeout_seconds": 300,
        },
        "ui_settings": {
            "theme": "auto",  # auto, light, dark
            "show_hidden_files": False,
            "auto_update_definitions": True,
            "notifications_enabled": True,
            "minimize_to_tray": True,
            "show_scan_progress": True,
            "activity_log_retention": 100,  # Number of recent activity messages to retain
            "show_notifications": True,
        },
        "security_settings": {
            "quarantine_enabled": True,
            "auto_quarantine_threats": False,
            "scan_removable_media": True,
            # Default: OFF - User can enable for continuous monitoring
            "real_time_protection": False,
            "auto_update_definitions": True,
        },
        "advanced_settings": {
            "signature_sources": ["main.cvd", "daily.cvd", "bytecode.cvd"],
            "custom_signature_urls": [],
            "log_level": "INFO",
            "scan_timeout": 300,
            "update_frequency": "daily",
            "scan_archives": True,
            "follow_symlinks": False,
            "scan_depth": 2,
            "file_filter": "all",
            "memory_limit": 1024,
            "exclusion_patterns": "",
        },
        "realtime_protection": {
            "monitor_modifications": True,
            "monitor_new_files": True,
            "scan_modified_files": False,
        },
        "rkhunter_settings": {
            "enabled": False,
            "run_with_full_scan": False,
            "auto_update": True,
            "categories": {
                "applications": False,
                "network": True,
                "rootkits": True,
                "system_commands": True,
                "system_integrity": True,
            },
        },
        "scheduled_settings": {
            "enabled": False,
            "frequency": "daily",
            "time": "02:00",
        },
        "paths": {
            "quarantine_dir": str(QUARANTINE_DIR),
            "scan_reports_dir": str(SCAN_REPORTS_DIR),
            "log_dir": str(LOG_DIR),
            "temp_dir": str(CACHE_DIR / "temp"),
        },
    }
