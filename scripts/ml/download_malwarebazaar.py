#!/usr/bin/env python3
"""
Download malware samples from MalwareBazaar API.

MalwareBazaar (https://bazaar.abuse.ch/) provides fresh malware samples
via a free REST API. This script downloads recent samples for ML training.

Usage:
    uv run python scripts/ml/download_malwarebazaar.py --samples 50000

API Documentation: https://bazaar.abuse.ch/api/
"""

import argparse
import hashlib
import json
import time
import os
from pathlib import Path
from typing import Optional
import io

import requests
import pyzipper
from rich.console import Console
from rich.progress import (
    Progress,
    SpinnerColumn,
    TextColumn,
    BarColumn,
    TaskProgressColumn,
)

console = Console()

# MalwareBazaar API endpoint
API_URL = "https://mb-api.abuse.ch/api/v1/"

# Output directory
MALWARE_DIR = Path("data/malware")
METADATA_FILE = MALWARE_DIR / "metadata.json"

# SECURITY: Rate limiting with exponential backoff (CWE-770 mitigation)
REQUEST_DELAY = 1.0  # seconds between requests (base delay)
MAX_RETRIES = 3  # maximum retry attempts
BACKOFF_FACTOR = 2.0  # exponential backoff multiplier
MAX_DELAY = 60.0  # maximum delay between retries
BATCH_SIZE = 100  # samples per batch


class MalwareBazaarDownloader:
    """Download malware samples from MalwareBazaar API."""

    def __init__(
        self, output_dir: Path, delay: float = REQUEST_DELAY, api_key: str | None = None
    ):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.delay = delay
        self.retry_count = 0
        self.session = requests.Session()

        # SECURITY: Load API key from environment variable (CWE-798 mitigation)
        api_key = api_key or os.getenv("MALWAREBAZAAR_API_KEY")

        headers = {"User-Agent": "xanadOS-ML-Training/3.1.0"}
        if api_key:
            headers["Auth-Key"] = api_key
        else:
            console.print(
                "[yellow]‚ö†Ô∏è  No API key found. Set MALWAREBAZAAR_API_KEY environment variable for authenticated access."
            )

        self.session.headers.update(headers)
        self.metadata = self._load_metadata()

    def _load_metadata(self) -> dict:
        """Load existing metadata or create new."""
        if METADATA_FILE.exists():
            return json.loads(METADATA_FILE.read_text())
        return {"samples": {}, "download_stats": {}}

    def _save_metadata(self):
        """Save metadata to JSON."""
        METADATA_FILE.write_text(json.dumps(self.metadata, indent=2))

    def get_recent_samples(self, limit: int = 100) -> list[dict]:
        """Get recent malware samples from API with retry logic."""
        # SECURITY: Exponential backoff retry logic (CWE-770 mitigation)
        for attempt in range(MAX_RETRIES):
            try:
                response = self.session.post(
                    API_URL,
                    data={"query": "get_recent", "selector": str(limit)},
                    timeout=30,
                )

                # Check for rate limiting (HTTP 429)
                if response.status_code == 429:
                    retry_after = int(response.headers.get("Retry-After", 60))
                    delay = min(retry_after, MAX_DELAY)
                    console.print(
                        f"[yellow]‚è±Ô∏è  Rate limited. Waiting {delay}s before retry..."
                    )
                    time.sleep(delay)
                    continue

                response.raise_for_status()

                data = response.json()
                if data.get("query_status") == "ok":
                    return data.get("data", [])
                else:
                    console.print(f"[yellow]API returned: {data.get('query_status')}")
                    return []

            except requests.exceptions.RequestException as e:
                if attempt < MAX_RETRIES - 1:
                    # Exponential backoff
                    delay = min(self.delay * (BACKOFF_FACTOR**attempt), MAX_DELAY)
                    console.print(
                        f"[yellow]‚ö†Ô∏è  API request failed (attempt {attempt + 1}/{MAX_RETRIES}): {e}"
                    )
                    console.print(f"[yellow]‚è±Ô∏è  Retrying in {delay:.1f}s...")
                    time.sleep(delay)
                else:
                    console.print(
                        f"[red]‚ùå API request failed after {MAX_RETRIES} attempts: {e}"
                    )
                    return []

        return []

    def download_sample(self, sha256_hash: str) -> Optional[Path]:
        """Download a single sample by SHA256 hash."""
        # Check if already downloaded
        output_path = self.output_dir / sha256_hash
        if output_path.exists():
            console.print(f"[dim]‚è≠Ô∏è  Skip (exists): {sha256_hash[:16]}...")
            return output_path

        try:
            # Request sample download
            response = self.session.post(
                API_URL,
                data={"query": "get_file", "sha256_hash": sha256_hash},
                timeout=60,
            )

            if response.status_code == 200:
                content = response.content

                # Check if it's a JSON error response
                if content.startswith(b"{"):
                    error_data = json.loads(content)
                    console.print(
                        f"[yellow]‚ö†Ô∏è  {sha256_hash[:16]}: {error_data.get('query_status', 'unknown error')}"
                    )
                    return None

                # Extract from password-protected ZIP
                try:
                    with pyzipper.AESZipFile(io.BytesIO(content)) as zf:
                        # Get the first file in the ZIP
                        names = zf.namelist()
                        if not names:
                            console.print(f"[yellow]‚ö†Ô∏è  {sha256_hash[:16]}: Empty ZIP")
                            return None

                        # Extract with password "infected"
                        extracted_content = zf.read(names[0], pwd=b"infected")

                        # Verify SHA256 of extracted content
                        downloaded_hash = hashlib.sha256(extracted_content).hexdigest()
                        if downloaded_hash.lower() != sha256_hash.lower():
                            console.print(f"[red]‚ùå Hash mismatch: {sha256_hash[:16]}")
                            return None

                        # SECURITY: Save with secure permissions AFTER hash verification (CWE-345 mitigation)
                        output_path.write_bytes(extracted_content)
                        output_path.chmod(0o600)  # Owner read/write only

                        # Post-write verification (defense in depth)
                        post_write_hash = hashlib.sha256(
                            output_path.read_bytes()
                        ).hexdigest()
                        if post_write_hash.lower() != sha256_hash.lower():
                            console.print(
                                f"[red]‚ùå Post-write hash mismatch: {sha256_hash[:16]}"
                            )
                            output_path.unlink()
                            return None

                        console.print(
                            f"[green]‚úÖ Downloaded: {sha256_hash[:16]}... ({len(extracted_content):,} bytes)"
                        )
                        return output_path

                except Exception as e:
                    console.print(
                        f"[red]‚ùå ZIP extraction failed: {sha256_hash[:16]}: {e}"
                    )
                    return None

            else:
                console.print(
                    f"[yellow]‚ö†Ô∏è  HTTP {response.status_code}: {sha256_hash[:16]}"
                )
                return None

        except requests.exceptions.RequestException as e:
            console.print(f"[red]‚ùå Download failed: {sha256_hash[:16]}: {e}")
            return None

    def download_batch(self, target_samples: int = 50000):
        """Download malware samples in batches."""
        console.print(f"\n[bold cyan]ü¶† MalwareBazaar Downloader")
        console.print(f"[cyan]Target: {target_samples:,} malware samples")
        console.print(f"[cyan]Output: {self.output_dir}")
        console.print()

        downloaded_count = 0
        skipped_count = 0
        failed_count = 0

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console,
        ) as progress:

            task = progress.add_task(
                "[cyan]Downloading samples...", total=target_samples
            )

            while downloaded_count < target_samples:
                # Get batch of recent samples
                samples = self.get_recent_samples(limit=BATCH_SIZE)

                if not samples:
                    console.print("[yellow]‚ö†Ô∏è  No more samples available from API")
                    break

                for sample in samples:
                    if downloaded_count >= target_samples:
                        break

                    sha256 = sample.get("sha256_hash")
                    if not sha256:
                        continue

                    # Download sample
                    result = self.download_sample(sha256)

                    if result:
                        downloaded_count += 1

                        # Store metadata
                        self.metadata["samples"][sha256] = {
                            "file_name": sample.get("file_name"),
                            "file_type": sample.get("file_type"),
                            "file_size": sample.get("file_size"),
                            "signature": sample.get("signature"),
                            "first_seen": sample.get("first_seen"),
                            "tags": sample.get("tags", []),
                        }
                    elif result is None:
                        failed_count += 1
                    else:
                        skipped_count += 1

                    progress.update(task, completed=downloaded_count + skipped_count)

                    # Rate limiting
                    time.sleep(self.delay)

                # Save metadata after each batch
                self._save_metadata()

        console.print()
        console.print(f"[bold green]‚úÖ Download Complete!")
        console.print(f"[green]Downloaded: {downloaded_count:,} samples")
        console.print(f"[yellow]Skipped: {skipped_count:,} (already exist)")
        console.print(f"[red]Failed: {failed_count:,}")
        console.print(
            f"[cyan]Total size: {sum(p.stat().st_size for p in self.output_dir.glob('*') if p.is_file()) / 1e9:.2f} GB"
        )

        # Update download stats
        self.metadata["download_stats"] = {
            "total_downloaded": downloaded_count,
            "total_skipped": skipped_count,
            "total_failed": failed_count,
            "last_updated": time.strftime("%Y-%m-%d %H:%M:%S"),
        }
        self._save_metadata()


def main():
    parser = argparse.ArgumentParser(
        description="Download malware samples from MalwareBazaar"
    )
    parser.add_argument(
        "--samples",
        type=int,
        default=50000,
        help="Number of samples to download (default: 50000)",
    )
    parser.add_argument(
        "--delay",
        type=float,
        default=REQUEST_DELAY,
        help=f"Delay between requests in seconds (default: {REQUEST_DELAY})",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=MALWARE_DIR,
        help=f"Output directory (default: {MALWARE_DIR})",
    )
    parser.add_argument(
        "--api-key",
        type=str,
        default="c3798f9796bbe6130e8dcfca176eb7a22fde44739447163d",
        help="MalwareBazaar API key (required for downloads)",
    )

    args = parser.parse_args()

    console.print("[bold red]‚ö†Ô∏è  WARNING: This script downloads LIVE MALWARE samples!")
    console.print("[red]‚Ä¢ Never execute files from the download directory")
    console.print("[red]‚Ä¢ Use isolated VM/container for analysis")
    console.print("[red]‚Ä¢ Ensure proper security measures are in place")
    console.print()

    response = console.input("[bold yellow]Continue? (yes/no): ")
    if response.lower() != "yes":
        console.print("[cyan]Download cancelled.")
        return

    downloader = MalwareBazaarDownloader(
        output_dir=args.output_dir, delay=args.delay, api_key=args.api_key
    )

    downloader.download_batch(target_samples=args.samples)


if __name__ == "__main__":
    main()
